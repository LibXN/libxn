/* "rfc5892_rules.c" */
/*
  generated by ucd.pl @ vmgentoo [Thu Aug 30 20:16:48 2012]
     - do not edit this file, edit ucd.pl instead -

*/
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef WIN32
#include "config.win32.h"
#endif

#include <stddef.h>

#include "xn.h"
#include "ucd.h"

  
#include "rfc5892_rules.h"

/*
  Contextual Rules Registry
  see: http://tools.ietf.org/html/rfc5892#appendix-A
*/
#line 110 "../gen/inc/rfc5892_rules.pl"

/* contextual rule signature */
typedef rfc5892_context_result
  (*rfc5892rule)(const ucd_record[],size_t,size_t);

/* rule data */
struct RFC5892_RULE
{
  codepoint_t lo;
  codepoint_t up;
  rfc5892rule rule;
  const char *name;
  char lookup;
};

static const struct RFC5892_RULE registry[9];


/* ---- BEGIN "rfc5892_rules.in.c" ---- */
#line 1 "../gen/src/rfc5892_rules.in.c"


/* Apply a contextual rule to a given label with respect to a specific position. */
rfc5892_context_result rfc5892_check_contextual_rule(
  const ucd_record label[], size_t label_l, size_t pos, int lookup,
  const char **rule_name)
{
  rfc5892_context_result res = rfc5892_context_Undef;
  codepoint_t cp = label[pos].cp;
  size_t i;

  /*
  RFC 5892
  
  A character with the derived property value CONTEXTJ or CONTEXTO
  (CONTEXTUAL RULE REQUIRED) is not to be used unless an appropriate
  rule has been established and the context of the character is
  consistent with that rule.  It is invalid to either register a string
  containing these characters or even to look one up unless such a
  contextual rule is found and satisfied.
  */
  
  /* argument consistence */
  if (!(pos < label_l))
    return rfc5892_context_Undef;
  if (!(label[pos].rfc5892 == rfc5892_CONTEXTJ ||
      label[pos].rfc5892 == rfc5892_CONTEXTO))
    return rfc5892_context_True;

  /* rule registry lookup */
  for (i = 0; i < 9; i++)
    if (cp <= registry[i].up && cp >= registry[i].lo)
    {  /* rule found */
    
      /* At lookup time:
        - For CONTEXTO, only the existance of a rule has to be verified.
        - For CONTEXTJ, only the joiner rules (Lookup: True) have to be applied. */
      if (lookup &&
          (label[pos].rfc5892 == rfc5892_CONTEXTO || !registry[i].lookup))
        return rfc5892_context_True;

      /* apply rule */
      if (rfc5892_context_True == (res = (*registry[i].rule)(label,label_l,pos)))
      {   /* A contextual rule is found and satisfied. */
        return rfc5892_context_True;
      }
      else /* Rule not satisfied. */
      {
        /* Taking RFC 5892 literally, we have to check whether another rule
         is satisfied (although actually at most one rule apply). */

        /* remeber the rule name for error reporting */
        *rule_name = registry[i].name;
      }
      
    }

  /* If no rule was found, the code point must be rejected. */
  return res;
}


/* ---- END "rfc5892_rules.in.c" ---- */


/* ---- BEGIN "rfc5892__a1_zero_width_non_joiner.in.c" ---- */
#line 1 "../gen/src/rfc5892__a1_zero_width_non_joiner.in.c"
/*
RFC 5892 contextual rule

Appendix A.1. ZERO WIDTH NON-JOINER


   Code point:
      U+200C

   Overview:
      This may occur in a formally cursive script (such as Arabic) in a
      context where it breaks a cursive connection as required for
      orthographic rules, as in the Persian language, for example.  It
      also may occur in Indic scripts in a consonant-conjunct context
      (immediately following a virama), to control required display of
      such conjuncts.

   Lookup:
      True

   Rule Set:

      False;

      If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True;

      If RegExpMatch((Joining_Type:{L,D})(Joining_Type:T)*\u200C

         (Joining_Type:T)*(Joining_Type:{R,D})) Then True;

*/
static rfc5892_context_result
rfc5892__a1_zero_width_non_joiner(
  const ucd_record label[], size_t label_l, size_t pos)
{
  size_t i;
  int valid;

  /* Before(cp) must be defined */
  if (pos == 0)
    return rfc5892_context_Undef;

  /* If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True; */
  if (label[pos-1].ccc == 9 /* Virama */)
    return rfc5892_context_True;


  /* If RegExpMatch((Joining_Type:{L,D})(Joining_Type:T)*\u200C
         (Joining_Type:T)*(Joining_Type:{R,D})) Then True;
  Thus, \u200C must occur between Joining_Type:{L,D} and Joining_Type:{R,D},
  where arbitrary occurences of Joining_Type:T may be in between. */
  
  /* REM:
  Assuming that "\u200C" within the regex means the code point in question,
  because otherwise the rule would be satisfied already if only the regex
  matches somewhere in the string. This makes a difference, doesn't it? */

  /* check before pos */
  for (valid = 0, i = pos - 1; i >= 0; i--)
  {
    if (label[i].joining_type == ucd_joining_T)
      continue;
    valid = (label[i].joining_type == ucd_joining_L ||
          label[i].joining_type == ucd_joining_D);
    break;
  }
  
  if (valid)
  {
    /* check after pos */
    for (valid = 0, i = pos + 1; i < label_l; i++)
    {
      if (label[i].joining_type == ucd_joining_T)
        continue;
      valid = (label[i].joining_type == ucd_joining_R ||
            label[i].joining_type == ucd_joining_D);
      break;
    }

    if (valid)
      return rfc5892_context_True;
  }

  return rfc5892_context_False;
}


/* ---- END "rfc5892__a1_zero_width_non_joiner.in.c" ---- */


/* ---- BEGIN "rfc5892__a2_zero_width_joiner.in.c" ---- */
#line 1 "../gen/src/rfc5892__a2_zero_width_joiner.in.c"
/*
RFC 5892 contextual rule

Appendix A.2. ZERO WIDTH JOINER


   Code point:
      U+200D

   Overview:
      This may occur in Indic scripts in a consonant-conjunct context
      (immediately following a virama), to control required display of
      such conjuncts.

   Lookup:
      True

   Rule Set:

      False;

      If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True;

*/
static rfc5892_context_result
rfc5892__a2_zero_width_joiner(
  const ucd_record label[], size_t label_l, size_t pos)
{

  /* Before(cp) required */
  if (pos == 0)
    return rfc5892_context_Undef;

  /* If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True; */
  if (label[pos-1].ccc == 9 /* Virama */)
    return rfc5892_context_True;

  return rfc5892_context_False;
}


/* ---- END "rfc5892__a2_zero_width_joiner.in.c" ---- */


/* ---- BEGIN "rfc5892__a3_middle_dot.in.c" ---- */
#line 1 "../gen/src/rfc5892__a3_middle_dot.in.c"
/*
RFC 5892 contextual rule

Appendix A.3. MIDDLE DOT


   Code point:
      U+00B7

   Overview:
      Between 'l' (U+006C) characters only, used to permit the Catalan
      character ela geminada to be expressed.

   Lookup:
      False

   Rule Set:

      False;

      If Before(cp) .eq.  U+006C And

         After(cp) .eq.  U+006C Then True;

*/
static rfc5892_context_result
rfc5892__a3_middle_dot(
  const ucd_record label[], size_t label_l, size_t pos)
{

  if (pos == 0 || pos == label_l-1)
    return rfc5892_context_Undef;
    
  if (label[pos-1].cp == 0x006C && label[pos+1].cp == 0x006C)
    return rfc5892_context_True;

  return rfc5892_context_False;
}


/* ---- END "rfc5892__a3_middle_dot.in.c" ---- */


/* ---- BEGIN "rfc5892__a4_greek_lower_numeral_sign_keraia.in.c" ---- */
#line 1 "../gen/src/rfc5892__a4_greek_lower_numeral_sign_keraia.in.c"
/*
RFC 5892 contextual rule

Appendix A.4. GREEK LOWER NUMERAL SIGN (KERAIA)


   Code point:
      U+0375

   Overview:
      The script of the following character MUST be Greek.

   Lookup:
      False

   Rule Set:

      False;

      If Script(After(cp)) .eq.  Greek Then True;

*/
static rfc5892_context_result
rfc5892__a4_greek_lower_numeral_sign_keraia(
  const ucd_record label[], size_t label_l, size_t pos)
{

  if (pos == label_l-1)
    return rfc5892_context_Undef;
    
  if (label[pos+1].script == ucd_script_Greek)
    return rfc5892_context_True;

  return rfc5892_context_False;
}


/* ---- END "rfc5892__a4_greek_lower_numeral_sign_keraia.in.c" ---- */


/* ---- BEGIN "rfc5892__a5_hebrew_punctuation_geresh.in.c" ---- */
#line 1 "../gen/src/rfc5892__a5_hebrew_punctuation_geresh.in.c"
/*
RFC 5892 contextual rule

Appendix A.5. HEBREW PUNCTUATION GERESH


   Code point:
      U+05F3

   Overview:
      The script of the preceding character MUST be Hebrew.

   Lookup:
      False

   Rule Set:

      False;

      If Script(Before(cp)) .eq.  Hebrew Then True;

*/
static rfc5892_context_result
rfc5892__a5_hebrew_punctuation_geresh(
  const ucd_record label[], size_t label_l, size_t pos)
{
  if (pos == 0)
    return rfc5892_context_Undef;

  if (label[pos-1].script == ucd_script_Hebrew)
    return rfc5892_context_True;

  return rfc5892_context_False;
}


/* ---- END "rfc5892__a5_hebrew_punctuation_geresh.in.c" ---- */


/* ---- BEGIN "rfc5892__a6_hebrew_punctuation_gershayim.in.c" ---- */
#line 1 "../gen/src/rfc5892__a6_hebrew_punctuation_gershayim.in.c"
/*
RFC 5892 contextual rule

Appendix A.6. HEBREW PUNCTUATION GERSHAYIM


   Code point:
      U+05F4

   Overview:
      The script of the preceding character MUST be Hebrew.

   Lookup:
      False

   Rule Set:

      False;

      If Script(Before(cp)) .eq.  Hebrew Then True;

*/
static rfc5892_context_result
rfc5892__a6_hebrew_punctuation_gershayim(
  const ucd_record label[], size_t label_l, size_t pos)
{
  if (pos == 0)
    return rfc5892_context_Undef;

  if (label[pos-1].script == ucd_script_Hebrew)
    return rfc5892_context_True;

  return rfc5892_context_False;
}


/* ---- END "rfc5892__a6_hebrew_punctuation_gershayim.in.c" ---- */


/* ---- BEGIN "rfc5892__a7_katakana_middle_dot.in.c" ---- */
#line 1 "../gen/src/rfc5892__a7_katakana_middle_dot.in.c"
/*
RFC 5892 contextual rule

Appendix A.7. KATAKANA MIDDLE DOT


   Code point:
      U+30FB

   Overview:
      Note that the Script of Katakana Middle Dot is not any of
      "Hiragana", "Katakana", or "Han".  The effect of this rule is to
      require at least one character in the label to be in one of those
      scripts.

   Lookup:
      False

   Rule Set:

      False;

      For All Characters:

         If Script(cp) .in. {Hiragana, Katakana, Han} Then True;

      End For;

*/
static rfc5892_context_result
rfc5892__a7_katakana_middle_dot(
  const ucd_record label[], size_t label_l, size_t pos)
{
  size_t i;
  
  for (i = 0; i < label_l; i++)
    if (
      label[i].script == ucd_script_Hiragana ||
      label[i].script == ucd_script_Katakana ||
      label[i].script == ucd_script_Han)
    return rfc5892_context_True;

  return rfc5892_context_False;
}


/* ---- END "rfc5892__a7_katakana_middle_dot.in.c" ---- */


/* ---- BEGIN "rfc5892__a8_arabic_indic_digits.in.c" ---- */
#line 1 "../gen/src/rfc5892__a8_arabic_indic_digits.in.c"
/*
RFC 5892 contextual rule

Appendix A.8. ARABIC-INDIC DIGITS


   Code point:
      0660..0669

   Overview:
      Can not be mixed with Extended Arabic-Indic Digits.

   Lookup:
      False

   Rule Set:

      True;

      For All Characters:

         If cp .in. 06F0..06F9 Then False;

      End For;

*/
static rfc5892_context_result
rfc5892__a8_arabic_indic_digits(
  const ucd_record label[], size_t label_l, size_t pos)
{
  size_t i;

  for (i = 0; i < label_l; i++)
    if (label[i].cp >= 0x06F0 && label[i].cp <= 0x06F9)
      return rfc5892_context_False;

  return rfc5892_context_True;
}


/* ---- END "rfc5892__a8_arabic_indic_digits.in.c" ---- */


/* ---- BEGIN "rfc5892__a9_extended_arabic_indic_digits.in.c" ---- */
#line 1 "../gen/src/rfc5892__a9_extended_arabic_indic_digits.in.c"
/*
RFC 5892 contextual rule

Appendix A.9. EXTENDED ARABIC-INDIC DIGITS


   Code point:
      06F0..06F9

   Overview:
      Can not be mixed with Arabic-Indic Digits.

   Lookup:
      False

   Rule Set:

      True;

      For All Characters:

         If cp .in. 0660..0669 Then False;

      End For;

*/
static rfc5892_context_result
rfc5892__a9_extended_arabic_indic_digits(
  const ucd_record label[], size_t label_l, size_t pos)
{
  size_t i;

  for (i = 0; i < label_l; i++)
    if (label[i].cp >= 0x0660 && label[i].cp <= 0x0669)
      return rfc5892_context_False;

  return rfc5892_context_True;
}


/* ---- END "rfc5892__a9_extended_arabic_indic_digits.in.c" ---- */


#line 145 "../gen/inc/rfc5892_rules.pl"
/* the registry */
static const struct RFC5892_RULE registry[]={
{lo:0x200C,up:0x200C,rule:&rfc5892__a1_zero_width_non_joiner,name:"A.1. ZERO WIDTH NON-JOINER",lookup:1},
{lo:0x200D,up:0x200D,rule:&rfc5892__a2_zero_width_joiner,name:"A.2. ZERO WIDTH JOINER",lookup:1},
{lo:0xB7,up:0xB7,rule:&rfc5892__a3_middle_dot,name:"A.3. MIDDLE DOT",lookup:0},
{lo:0x375,up:0x375,rule:&rfc5892__a4_greek_lower_numeral_sign_keraia,name:"A.4. GREEK LOWER NUMERAL SIGN (KERAIA)",lookup:0},
{lo:0x5F3,up:0x5F3,rule:&rfc5892__a5_hebrew_punctuation_geresh,name:"A.5. HEBREW PUNCTUATION GERESH",lookup:0},
{lo:0x5F4,up:0x5F4,rule:&rfc5892__a6_hebrew_punctuation_gershayim,name:"A.6. HEBREW PUNCTUATION GERSHAYIM",lookup:0},
{lo:0x30FB,up:0x30FB,rule:&rfc5892__a7_katakana_middle_dot,name:"A.7. KATAKANA MIDDLE DOT",lookup:0},
{lo:0x660,up:0x669,rule:&rfc5892__a8_arabic_indic_digits,name:"A.8. ARABIC-INDIC DIGITS",lookup:0},
{lo:0x6F0,up:0x6F9,rule:&rfc5892__a9_extended_arabic_indic_digits,name:"A.9. EXTENDED ARABIC-INDIC DIGITS",lookup:0}};


/* end of generated file */
